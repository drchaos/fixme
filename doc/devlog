
## 2023-02-10

TODO: define-how-to-process-log

  Что бы писать в fixmeattrlog что-то релевантное (хэш самого файла? хэш коммита?)
  нужно определить политику, что туда писать.

  Допустим, это хэш самого файла. Тогда можно его произвольно менять до коммита,
  запускать fixme scan, он будет менять атрибуты, потом еще раз поменять
  лог и закоммитить.

  В итоге, rev в fixmeattrlog будет ссылаться на несуществующий в гите объект.

  Как с этим бороться пока не очень понятно.

  Можно принудительно читать только закоммиченный лог. Тогда это будет
  вызывать удивление -- т.к текущее состояние в рабочей копии будет
  игнорироваться.


## 2023-02-09

TODO: skip-empty-fixmies

  ignore empty fixme entries


TODO: test-uuid
 $(uuid ce6655b5-840c-4ddd-9916-0909ed921c48)

 Рандомный uuid делает любой fixme уникальным


TODO: fixme-uuid-command

  Сделать команду

  ```
  fixme uuid
  ```

  которая будет генерировать uuid  в виде строки uuid: <UUID>
  которую можно будет вставлять в fixme и обеспечивать тем самым
  его уникальность.

  wtf?


## 2023-02-08

TODO:  fixme-from-git-rev-list
 На самом деле, нужно не парсить файлы проекта по маске,
 а получать список объектов текущего дерева из
 ```
   git ls-tree -r master
 ```
 например. Тогда объекты будут гарантированно закоммичены,
 и не нужно будет озадачиваться вопросом, что делать, если
 id  у fixme есть, а контента нет (после коммита).

 Маска, впрочем, всё равно нужна --- что бы фильтровать файлы,
 которые использовать. filepattern будет работать в любом случае
 (хорошо!).


TODO:  fixme track command
  Делает так, что бы fixme становился постоянным и начинал отслеживаться.
  Как это сделать? Пока непонятно #tbd

FIXME: inline-fixmies-ignored
  Сейчас игнорируются fixmies, которые находятся в одной
  строке с кодом.

  Можно так и оставить, т.к. это создаёт много неоднозначностей.
  В конце концов, каждый такой fixme можно переписать так,
  что бы он соответствовал текущим соглашениям.


## 2023-02-07

Итак, приступим

FIXME: стрипать только indent пробелов,
  а то форматирование ломается.

TODO:  определить формат хранения статусов
   Варианты:
     1.  Просто в файле, текстовый лог изменений.
         Тогда будет шум в дифах. Можно сделать
         лог бинарным (с добавлением строго в конец),
         тогда не будет показывать в дифах, а просто,
         что файл изменён. Если сделать так, что бы
         файл писался строго в конец, то будет работать.

         Оценка:

           (-5) Кто угодно может перезаписать и все к
                черту покорраптится

           (+1) Можно откатить к предыдущей версии

           (+1) Просто

     2. Одна операция (серия операций) --- один
        git объект.

        Оценка:

           (+1) Файл в репозитории, что бы найти и поломать
                требуются специальные усилия и тогда
                поменяется его хэш.

           (+1) Не будет шума в логах

           (-2) Требуются специальные усилия, что бы эти
                объекты синхронизировались:

                Нужно создавать tree object, commit object.
                В узлы tree object прописывать файлы изменений.

                Прописывать результат в специальный ref.

                Самим пушить этот ref.


TODO: вычислять id для fixme

  Определить, что является id для fixme. Это может быть,
  например, хэш от ключевой информации -- хэш файла+позиция
  + какая-то соль, возможно. Нужно, что бы у всех были
  одинаковые ID, что наводит на мысль, что это должно быть
  hash(hash(blob)+position).

  С одной стороны, это достаточно однозначный идентификатор,
  который в случае использования git будет у всех одинаковый
  для данной версии файла.

  С другой стороны --- он длинный, что неудобно.

  С третьей стороны --- можно выводить префикс определенной
  длины и обрабатывать коллизии. Как делают в гите.

  Наверное, это наш путь, особенно, если брать достаточно
  длинный префикс в base58.


TODO: читать весь FIXME, не только заголовок

TODO: считать хэши для каждого FIXME

TODO: идентацию для каждого FIXME

FIXME:  найти файлы по маске

FIXME: найти все вхождения для fixme в найденных
  файлах, имея в виду следующий формат:

  ```
  identation comment space+ tag space space* char char* eol
  (identation comment space+ char* eol)+
  eol | identation /= fixme.identation
  ```


